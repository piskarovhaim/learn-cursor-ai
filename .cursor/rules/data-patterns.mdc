---
alwaysApply: true
---
# Data Handling Patterns

**All data operations must follow these strict patterns for consistency and type safety.**

## Architecture Overview

**ALL database operations (queries and mutations) MUST be defined as helper functions in the `db/queries/` directory.**

This architecture provides:
- ✅ Centralized data access logic
- ✅ Reusability across components and actions
- ✅ Better testability
- ✅ Single source of truth for queries
- ✅ Easier refactoring and maintenance

### Directory Structure

```
src/
  db/
    queries/
      decks.ts      # Deck-related queries
      cards.ts      # Card-related queries
    index.ts        # Database client
    schema.ts       # Schema definitions
```

## Data Retrieval

**All data fetching must be done through query helper functions called from Server Components.**

### ✅ Correct - Query helper functions + Server Components

```typescript
// db/queries/decks.ts
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

// All query functions should be exported for reuse
export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db.select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
  
  return deck || null;
}

export async function getDeckWithCards(deckId: number, userId: string) {
  return await db.query.decksTable.findFirst({
    where: and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ),
    with: {
      cards: true
    }
  });
}
```

```typescript
// app/dashboard/page.tsx (Server Component)
import { auth } from '@clerk/nextjs';
import { getUserDecks } from '@/db/queries/decks';

export default async function DashboardPage() {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  // Call query helper function
  const decks = await getUserDecks(userId);

  return (
    <div>
      {decks.map(deck => (
        <div key={deck.id}>{deck.name}</div>
      ))}
    </div>
  );
}
```

### ❌ Incorrect - Direct database queries or wrong patterns

```typescript
// ❌ FORBIDDEN - Direct database query in Server Component
export default async function DashboardPage() {
  const { userId } = await auth();
  
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId)); // ❌ Should use query helper
}

// ❌ FORBIDDEN - Fetch data in Client Components
'use client';
export default function DashboardPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    fetch('/api/decks').then(/* ... */); // ❌ Wrong pattern
  }, []);
}

// ❌ FORBIDDEN - Create API routes just to fetch data for display
// app/api/decks/route.ts
export async function GET() {
  const decks = await db.select().from(decksTable);
  return NextResponse.json(decks);
}
```

## Data Mutations

**All database mutations (INSERT, UPDATE, DELETE) must be done through mutation helper functions called from Server Actions.**

### ✅ Correct - Mutation helper functions + Server Actions

```typescript
// db/queries/decks.ts (continued)
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

// === MUTATION HELPERS ===

export async function createDeck(data: {
  userId: string;
  name: string;
  description?: string;
}) {
  const [newDeck] = await db.insert(decksTable)
    .values({
      userId: data.userId,
      name: data.name,
      description: data.description,
    })
    .returning();

  return newDeck;
}

export async function updateDeck(data: {
  id: number;
  userId: string;
  name: string;
  description?: string;
}) {
  // Verify ownership first
  const deck = await getDeckById(data.id, data.userId);
  
  if (!deck) {
    throw new Error('Deck not found or unauthorized');
  }

  const [updatedDeck] = await db.update(decksTable)
    .set({
      name: data.name,
      description: data.description,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, data.id),
      eq(decksTable.userId, data.userId)
    ))
    .returning();

  return updatedDeck;
}

export async function deleteDeck(deckId: number, userId: string) {
  // Verify ownership before deletion
  const deck = await getDeckById(deckId, userId);
  
  if (!deck) {
    throw new Error('Deck not found or unauthorized');
  }

  await db.delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
}
```

```typescript
// actions/deck-actions.ts
'use server';

import { auth } from '@clerk/nextjs';
import { z } from 'zod';
import { 
  createDeck as dbCreateDeck,
  updateDeck as dbUpdateDeck,
  deleteDeck as dbDeleteDeck 
} from '@/db/queries/decks';

// Define Zod schema
const createDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  description: z.string().max(500).optional(),
});

// Define TypeScript type from schema
type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  // Validate input with Zod
  const validatedInput = createDeckSchema.parse(input);

  // Call mutation helper function
  return await dbCreateDeck({
    userId,
    name: validatedInput.name,
    description: validatedInput.description,
  });
}

// Update action
const updateDeckSchema = z.object({
  id: z.number(),
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
});

type UpdateDeckInput = z.infer<typeof updateDeckSchema>;

export async function updateDeck(input: UpdateDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  const validatedInput = updateDeckSchema.parse(input);

  // Call mutation helper function
  return await dbUpdateDeck({
    id: validatedInput.id,
    userId,
    name: validatedInput.name,
    description: validatedInput.description,
  });
}

// Delete action
const deleteDeckSchema = z.object({
  id: z.number(),
});

type DeleteDeckInput = z.infer<typeof deleteDeckSchema>;

export async function deleteDeck(input: DeleteDeckInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }

  const validatedInput = deleteDeckSchema.parse(input);

  // Call mutation helper function
  await dbDeleteDeck(validatedInput.id, userId);
}
```

### ✅ Correct - Using Server Actions in Client Components

```typescript
'use client';

import { createDeck } from '@/actions/deck-actions';
import { useState } from 'react';

export function CreateDeckForm() {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      // Call server action (which calls mutation helper)
      await createDeck({
        name,
        description,
      });
      
      // Handle success
      setName('');
      setDescription('');
    } catch (error) {
      // Handle error (Zod validation or other errors)
      console.error(error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Deck name"
      />
      <textarea
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="Description"
      />
      <button type="submit">Create Deck</button>
    </form>
  );
}
```

### ❌ Incorrect - Do NOT use these patterns

```typescript
// ❌ FORBIDDEN - Direct database mutation in Server Action
'use server';
export async function createDeck(input: CreateDeckInput) {
  const { userId } = await auth();
  const validatedInput = createDeckSchema.parse(input);
  
  // ❌ Should call mutation helper from db/queries
  await db.insert(decksTable).values({
    userId,
    ...validatedInput
  });
}

// ❌ FORBIDDEN - Direct database query in Server Component
export default async function DashboardPage() {
  const { userId } = await auth();
  
  // ❌ Should call query helper from db/queries
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}

// ❌ FORBIDDEN - FormData as parameter type
export async function createDeck(formData: FormData) {
  const name = formData.get('name'); // ❌ No type safety
}

// ❌ FORBIDDEN - Skip Zod validation
export async function createDeck(input: CreateDeckInput) {
  // Missing: const validatedInput = createDeckSchema.parse(input);
  await dbCreateDeck({ ...input, userId }); // ❌ Unvalidated input
}

// ❌ FORBIDDEN - API routes for mutations
// app/api/decks/route.ts
export async function POST(request: Request) {
  const body = await request.json();
  await db.insert(decksTable).values(body); // ❌ Wrong pattern
}

// ❌ FORBIDDEN - Database access in Client Components
'use client';
export function CreateDeckForm() {
  const handleSubmit = async () => {
    await db.insert(decksTable).values(/* ... */); // ❌ Cannot do this
  };
}

// ❌ FORBIDDEN - Untyped parameters
export async function createDeck(input: any) { // ❌ Use proper TypeScript types
  // ...
}
```

## Zod Validation Requirements

**All Server Action inputs must be validated with Zod.**

### Pattern for Server Actions:

1. Define Zod schema for input validation in the Server Action file
2. Infer TypeScript type from schema using `z.infer<>`
3. Use the inferred type for the function parameter
4. Parse/validate input with `schema.parse()` at the start of the action
5. Call the appropriate query/mutation helper from `db/queries`

```typescript
// actions/my-actions.ts
'use server';

import { auth } from '@clerk/nextjs';
import { z } from 'zod';
import { createMyEntity as dbCreateMyEntity } from '@/db/queries/my-entities';

// 1. Define schema
const myActionSchema = z.object({
  field: z.string().min(1),
});

// 2. Infer type
type MyActionInput = z.infer<typeof myActionSchema>;

// 3. Use type in function
export async function myAction(input: MyActionInput) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error('Unauthorized');
  }
  
  // 4. Validate
  const validatedInput = myActionSchema.parse(input);
  
  // 5. Call mutation helper
  return await dbCreateMyEntity({
    userId,
    ...validatedInput
  });
}
```

## Query/Mutation Helper Guidelines

### Query Helpers (`db/queries/*.ts`)

**Query helpers should:**
- Be pure database query functions
- Accept necessary parameters (userId, ids, filters)
- Return typed data
- NOT contain business logic or validation (that belongs in Server Actions)
- NOT call `auth()` directly (receive userId as parameter)
- Handle ownership verification for security

```typescript
// db/queries/decks.ts
export async function getUserDecks(userId: string) {
  return await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}
```

### Mutation Helpers (`db/queries/*.ts`)

**Mutation helpers should:**
- Be pure database mutation functions
- Accept necessary data including userId
- Verify ownership before mutations
- Return the created/updated data
- NOT contain input validation (that belongs in Server Actions)
- NOT call `auth()` directly (receive userId as parameter)

```typescript
// db/queries/decks.ts
export async function createDeck(data: {
  userId: string;
  name: string;
  description?: string;
}) {
  const [newDeck] = await db.insert(decksTable)
    .values(data)
    .returning();
  
  return newDeck;
}
```

## Architecture Flow

### Data Retrieval Flow:
```
Server Component
  → calls query helper from db/queries
    → executes database query
      → returns data
```

### Data Mutation Flow:
```
Client Component
  → calls Server Action from actions/
    → validates input with Zod
      → calls mutation helper from db/queries
        → executes database mutation
          → returns result
```

## Quick Checklist

### For Data Retrieval:
1. ✓ Did I create a query helper in `db/queries/`?
2. ✓ Am I calling the query helper from a Server Component?
3. ✓ Am I NOT doing direct `db.select()` in components?
4. ✓ Am I NOT creating an API route just for data display?
5. ✓ Am I following auth security rules (passing userId to helpers)?

### For Data Mutations:
1. ✓ Did I create a mutation helper in `db/queries/`?
2. ✓ Is my Server Action marked with 'use server'?
3. ✓ Did I define a Zod schema in the Server Action?
4. ✓ Did I infer a TypeScript type from the schema?
5. ✓ Did I use the inferred type (NOT `any`, NOT `FormData`)?
6. ✓ Did I validate with `schema.parse()` in the Server Action?
7. ✓ Am I calling the mutation helper (NOT direct `db.insert()`)?
8. ✓ Am I following auth security rules (passing userId to helpers)?

### For Query/Mutation Helpers:
1. ✓ Are they in the `db/queries/` directory?
2. ✓ Do they accept userId as a parameter (not calling `auth()` directly)?
3. ✓ Do they verify ownership for user-specific operations?
4. ✓ Are they reusable and well-typed?
5. ✓ Do they contain ONLY database logic (no validation, no business logic)?

**If you answer "no" to any of these, the code is incorrect.**
